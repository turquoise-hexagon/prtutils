#!/bin/bash
#
# prtversion - compare local versions to repology versions

die() {
    printf '%s\n' "${1:-usage : ${0##*/} <repo>}" >&2

    exit 1
}

sanitize_version() {
    ver=${1//[^0-9.-]}

    while [[ $ver =~ '.0'$ ]]; do
        ver=${ver%.0}
    done

    printf '%s\n' "$ver"
}

# store list of package files
while read -r path pkg; do
    for repo; {
        [[ ${path##*/} == "$repo" ]] && {
            pkgfiles+=("$path/$pkg/Pkgfile")
        }
    }
done <<< $(prt-get printf '%p %n\n')

((${#pkgfiles[@]})) || die

# store list of package versions
for pkgfile in "${pkgfiles[@]}"; {
    unset name commit version

    . "$pkgfile" 2> /dev/null &&
        # don't store git & commit packages
        [[ ! $commit && $version != git ]] && {
            pkgs+=("$name")
            vers+=("$(sanitize_version "$version")")
        }
}

# store a list of URLs
for pkg in "${pkgs[@]}"; {
    urls+=("https://repology.org/badge/latest-versions/$pkg.svg?header=")
}

# parse svgs
((index == 0))

while IFS= read -r line; do
    [[ ${line##*middle\">} =~ ([^<, ]+) ]] && {
        remote=$(sanitize_version "${BASH_REMATCH[1]}")

        pkg=${pkgs[index]}
        ver=${vers[index]}

        # take decision
        case $remote in
            -) out_u+=("$pkg : $ver -> $remote");;
            $ver) ;; # do nothing
            *) out_m+=("$pkg : $ver -> $remote");;
        esac
    }

    ((++index))
done <<< $(curl -w '\n' -s "${urls[@]}")

# print everything
for line in "${out_m[@]}" "${out_u[@]}"; {
    printf '%s\n' "$line"
}
